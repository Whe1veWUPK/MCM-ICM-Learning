# 遗传算法
是一种寻优算法——找最优解。这一理论假设**当前问题的最佳解是由多个要素组成的，当更多此类要素组合在一起时，将更接近于问题的最优解。**

种群中的个体包含一些最优解所需的要素，重复选择和交叉过程将个体将这些要素传达给下一代，同时可能将它们与其他最优解的基本要素结合起来。这将产生遗传压力，从而引导种群中越来越多的个体包含构成最佳解决方案的要素。

## 基本概念
- 染色体chromosome、基因gene：染色体指的是可行解**编码后的序列**，一般是一个数组或字符串，它的**每个分量**称为基因
- 适应度函数fitness function：用于评价每条染色体（可行解）的好坏的标准
- 种群population：染色体的集合，包含当前所有的候选解
- （单点）交叉crossover：是产生新染色体的过程，通过选取两条染色体的一部分构成新的染色体（[1,1,4,|5,1,4]+[1,8,2,|3,7,5]->[1,1,4,3,7,5],[1,8,2,5,1,4]，`|`是交叉点，有多种选取方法，比如`轮盘赌`）
- 变异mutation：以一定概率（一般比较小）改变可行解某几个分量的过程，改变的方法也不唯一。比如对于一个二进制串，可以将某一位反转
- 选择selection：选择父代（交叉前）和子代（交叉后）中的一部分染色体，用作下一轮迭代或输出。这里看到了两种不同的选法：可以直接选择适应度最高的k个，也可以在父代和子代中各自选择适应度最高的几个（如若要求下一代种群大小为k，父代选m个，子代就选k-m个）

交叉也可以采用其他方法：
- 多点交叉：生成多个交叉点，交换每两个交叉点之间的片段
- 均匀交叉：染色体上每个基因等概率地进行交叉操作
- 算术交叉：染色体之间线性组合（？理解大概是c=a\*x1+b\*x2, a+b=1且a>0, b>0）

## 准备
- 对问题的可行解域确定一种编码方式，用数值（数组）或字符串表示
- 确定适应度函数（一般就是优化问题的目标函数）
- 确定种群大小、交叉率（发生交叉的概率，可以取1）、变异率（一般比较小，如0.1）
- 确定迭代（进化）的次数，设置一个最大次数，设置一个可接受的结果范围，当可行解落入这个范围时提前终止算法

## 算法流程
1. 生成一组初始的可行解作为第一代染色体。
2. 根据适应度函数计算每条染色体的适应度，然后根据轮盘赌算法（即，某个染色体被选中的概率=它的适应度/所有染色体的适应度和）选择一组用于交叉的染色体。
3. 对选中的染色体组执行交叉操作，交叉点可以随机生成
4. 以一定变异率对子代执行变异操作
5. 如果适应度最高的染色体达到终止条件，则输出它，算法结束；否则选择父代和子代中适应度最小的M个染色体作为下一代（M是种群大小），然后回到步骤2


改良圈算法：P330的例子（旅行商问题）中，用来生成初始的可行解
- “圈”指的是一条Hamilton通路，即从起点到终点经过所有其他节点一次（ps：对于某个染色体来说，它的基因序列就可以看作一条Hamilton通路）
1. 随机生成一个初始圈
2. 将它的某一段逆序。如果初始圈是 $C=V_{0}\dots V_{i}\{V_{i+1}V_{i+2}\dots V_{j-1}V_{j}\}V_{j+1}V_{j+2}\dots V_{n-1}$ ，则将`i`和`j`中间的一段逆序之后的圈变为 $C^{'}=V_{0}\dots V_{i}\{V_{j}V_{j-1}\dots V_{i+2}V_{i+1}\}V_{j+1}V_{j+2}\dots V_{n-1}$ ，大括号中的部分是被逆序的段。逆序的实质是修改了路径中的两条边，它将 $(V_{i}, V_{i+1}), (V_{j}, V_{j+1})$ 变为 $(V_{i}, V_{j}), (V_{i+1}, V_{j+1})$ 
3. 根据逆序的实质来看，检验 $w(V_{i}V_{j})+w(V_{i+1}V_{j+1})< w(V_{i}V_{i+1})w(V_{j}V_{j+1})$ 是否成立，如果成立则用新的圈替换原有圈。
4. 对所有 $i< j$ 迭代L次，L是通路的长度（我觉得也可以是别的值）。每完成一轮迭代，检查圈是否被更新，如果没有更新则认为已经找到一个相对好的解

# 改进的遗传算法
## 改进交叉（单点）
1. 将父代个体按适应度排序，适应度大的之间配对，适应度小的和小的配对
2. 利用混沌序列确定交叉点位置。生成一个 $(0, 1)$ 上的随机数，然后利用Logistic混沌序列 $x(n+1)= 4x(n)[1-x(n)]$ 生成一系列相同区间上的混沌值，再将这些值映射到可行解的下标空间（比如，需要0-100的值，把它乘以100即可），作为交叉点的位置

## 改进变异
执行变异操作时，如果基因是 $(0, 1)$ 上的实数，那么在每条待变异的染色体上随机选取两个位置，然后生成一个长度为2n+1（n是变异的染色体数）的混沌序列ch（ch[0]随机生成），然后将第k条染色体被选中的两个基因的值变异为ch[k]和ch[k+1]
